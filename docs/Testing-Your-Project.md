# Testing Your Project

The generated code for your project comes with a reasonable test coverage out of the box.

This is built around the [AbstractEntityTest](../src/Entity/Testing/AbstractEntityTest.php)

The Abstract Entity test handles the creation and of a test entity and also associated entities.

## Faker

Faker is used to generate the data and there is a mechanism for Fields to provide their own Faker data provider if the standard Faker guessing mechanism is not good enough.

### Custom Faker Data

DSM provides a mechanims to generate faker data for your entities to use when testing.

Archetype fields come with a faker data provider that will generate field level faker data, or you can implement a customer faker data filler if you want to control it at a class/entity level.

#### Field Level

Faker does a great job of guessing values to provide based on the Entity meta data. However for some fields you might want to roll somethign more custom.

This can be done by creating a new class that implements the [FakerDataProviderInterface](./../src/Entity/Fields/FakerData/FakerDataProviderInterface.php)

Once you have created the class, you also need to override the AbstractEntityTest::FAKER_DATA_PROVIDERS constant in your child test class

#### Class Level

If you want to generate the faker data at a class level, for example when you have class level constraints that compare the values of multiple fields, then you need to implement a custom faker data filler.

The easiest way to do this is to provide a new class that extends FakerDataFiller. Allow the standard faker data to be generated and then update it as required.

Once you have a custom faker data filler, you need to register it in the [FakerDataFillerFactory](../src/Entity/Testing/EntityGenerator/FakerDataFillerFactory.php) which is used by the [TestEntityGenerator](../src/Entity/Testing/EntityGenerator/TestEntityGenerator.php)

You can choose to do this using DI configuration, or you can manually call the required methods within your tests.

See \EdmondsCommerce\DoctrineStaticMeta\Entity\Testing\EntityGenerator\FakerDataFillerFactory::setCustomFakerDataFillersFqns



## Fixtures

When generating an Entity, there is a also a Fixture class generated in the `tests/Assets/EntityFixtures` folder.

This class implements the `FixtureInterface` from the [doctrine/data-fixtures](https://github.com/doctrine/data-fixtures) module. This module provides a formal way of structuring and implementing test fixtures.

To use these fixtures, in your test class you should instantiate the [`FixturesHelper`](./../src/Entity/Testing/Fixtures/FixturesHelper.php) which provides you all the functionality to use your Fixtures to build up your test database. Also this helper will cache the SQL queries and can then just run the queries which can have a big speed improvement.

For each Fixture class generated by DSM, you can then instantiate it with your own `Modifier` which is an instance of [FixtureEntitiesModifierInterface](./../src/Entity/Testing/Fixtures/FixtureEntitiesModifierInterface.php). This is quite a small interface with only one method, though of course your implementation can be as complex as you like. As it is a small class, it is a good candidate for being implemented as an Anonymous class which is the way it is done in the [FixturesHelperTest](./../tests/Large/G/Entity/Testing/Fixtures/FixturesHelperTest.php)



### How to flush fixture data to the database #

The DSM fixtures keep the database clean by running the tests within a database transaction and then rolling this
back after the test is complete. This means that you can never view the fixture data in the database. In order to do
this you can temporarily update the following code:

```php
// \EdmondsCommerce\VaultTestingService\DsmFixturesTrait::removeFixtures

    public function removeFixtures(): void
    {
        $this->connection->getConnection()->rollBack();
    }
```

to

```php
// \EdmondsCommerce\VaultTestingService\DsmFixturesTrait::removeFixtures

    public function removeFixtures(): void
    {
        $this->connection->getConnection()->commit();
    }
```

This change will mean that you can only run one test at a time and you'll need to ensure that the database is dropped
and recreated between each run.

